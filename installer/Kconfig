# IMPORTANT: Happy Hare TOKEN naming convention and kconfig features:
#   PARAM_*                Symbols of various types used in template rendering
#   PIN_*                  Used for string symbols representing pins
#   BOOL_*                 Boolean symbols often used to set prompt-less int PARAMS
#   MMU_HAS_*              Used for MMU hardware components like encoder
#   CHOICE_X, CHOICE_X_*   Named choice "X" or boolean selection config
#   UNSELECT_*             Special boolean symbol used to implement forced "unselect"
#
# The above list is special is that default values will be stored in the .config but will not
# force setting on subsequent runs. They therefore remain as modifiable defaults until user explicitly
# changes them. Also when they are changed from default values menuconfig will mark as
# "(NOT DEFAULT)" and allow the "r" keystroke to reset back to default value
#   
# Other names will be store and handled as normal Kconfig variables. Therefore if you
# don't want the abilty to "reset to default" and you want past values to be "sticky" you
# must use alternative names (or unamed choice)
#
# Capability parmams:
#   MMU_HAS_BUFFER_MCU
#   MMU_HAS_ENCODER
#   MMU_HAS_ENVIRONMENT_SENSOR
#   MMU_HAS_ESPOOLER
#   MMU_HAS_FILAMENT_BUFFER
#   MMU_HAS_HEATER
#   MMU_HAS_LEDS
#   MMU_HAS_SELECTOR_SERVO
#   MMU_HAS_SELECTOR_STEPPER
#   MMU_HAS_SENSOR_EXTRUDER
#   MMU_HAS_SENSOR_GATE
#   MMU_HAS_SENSOR_GEAR_TOUCH
#   MMU_HAS_SENSOR_POST_GEAR
#   MMU_HAS_SENSOR_PRE_GATE
#   MMU_HAS_SENSOR_SYNC_FEEDBACK_COMPRESSION
#   MMU_HAS_SENSOR_SYNC_FEEDBACK_PROPORTIONAL
#   MMU_HAS_SENSOR_SYNC_FEEDBACK_TENSION
#   MMU_HAS_SENSOR_TOOLHEAD
#   MMU_HAS_SYNC_FEEDBACK_BUFFER


# IMPORTANT keep version string up-to-date and constistent with git tag
happy_hare_version := 4.0

f_version   := $(shell, printf '%s0\n' "$(happy_hare_version)" | sed -E 's/^([0-9]+)\.([0-9])([0-9]).*/\1.\2.\3/')
hh_message  := $(shell, echo "Happy Hare v$(f_version)")
unit_suffix := $(shell, [ -n "$$UNIT_NAME" ] && echo "Unit: [[B]]$(UNIT_NAME)[[/B]]" || echo "")
title       := $(shell, [ "$F_MULTI_UNIT_ENTRY_POINT" = "y" ] && echo "$(hh_message) Configuration for [[B]]Multi Unit Setup[[/B]]" || echo "$(hh_message) Configuration - $(unit_suffix)")
caption     := $(shell, [ "$F_MULTI_UNIT_ENTRY_POINT" = "y" ] && echo "$(hh_message) - [[B]]Shared Config[[/B]]" || echo "Configuration - $(unit_suffix)")
caption_pad := $(shell, [ "$F_MULTI_UNIT_ENTRY_POINT" = "y" ] && echo "61" || echo "61")

# Used to convert a shell command result to a y/n value
to_bool = $(shell, $(1) && echo y || echo n)

# Used to count arguments
count   = $(shell, set -- $(1); echo $#)

# Used to dynamically get the serial device paths (ls is not expensive to run multiple time)
serial_device        = $(shell, ls /dev/serial/by-id/* 2>/dev/null | grep 'Klipper_$(2)' | tail -n +$(1) | head -n 1)
serial_exists        = $(to_bool, [ -e '$(serial_device,$(1),$(2))' ])
mmu_serial_config    = $(shell, basename '$(serial_device,$(1),$(2))' | sed 's/-/_/g' | awk 'BEGIN{out="CHOICE_MMU_SERIAL_DEVICE_NONE" } NF && $$0!="." {out="CHOICE_MMU_SERIAL_DEVICE_" toupper($$0)} END{print out}')
buffer_serial_config = $(shell, basename '$(serial_device,$(1),$(2))' | sed 's/-/_/g' | awk 'BEGIN{out="CHOICE_BUFFER_SERIAL_DEVICE_NONE"} NF && $$0!="." {out="CHOICE_BUFFER_SERIAL_DEVICE_" toupper($$0)} END{print out}')

# Grab the UUIDs that are not in use by klipper as a space-separated list, e.g. "43a8... 25ff... aaba..."
canbus_query        := $(shell, echo "$(KLIPPER_HOME)/../klippy-env/bin/python $(KLIPPER_HOME)/scripts/canbus_query.py can0")
canbus_uuids        := $(shell, $(canbus_query) 2>/dev/null | sed -n 's/.*canbus_uuid=\([0-9a-fA-F][0-9a-fA-F]*\).*/\1/p')
canbus_uuid_count   := $(count, $(canbus_uuids))
canbus_uuid          = $(shell, echo $(canbus_uuids) | awk -v n=$(1) '{ print $n }')
mmu_canbus_config    = $(shell, echo $(canbus_uuid,$(1)) | awk 'BEGIN{out="CHOICE_MMU_CANBUS_UUID_NONE"} NF {out="CHOICE_MMU_CANBUS_UUID_" toupper($$0)} END{print out}')
buffer_canbus_config = $(shell, echo $(canbus_uuid,$(1)) | awk 'BEGIN{out="CHOICE_BUFFER_CANBUS_UUID_NONE"} NF {out="CHOICE_BUFFER_CANBUS_UUID_" toupper($$0)} END{print out}')

# Used for comment padding
pad = $(shell, printf "%-$(1)s" "$(2)")

# To allow multiline config strings.
# Important: Use $(comma) & $(quote) instead of real comma's or double quotes in multiline strings
# For portability, this is a posix version of: ml = $(shell, printf "$(1)" | sed -z "s/\\n/\\\\n/g")
comma := ,
quote := "
ml = $(shell, printf '%s' "$(1)" | awk -v ORS='\\n' '1')


### Start of configuration
mainmenu "$(title)"

config HAPPY_HARE_VERSION
  string
  default "$(happy_hare_version)"

config FORMATTED_VERSION
  string
  default "$(f_version)"

config MULTI_UNIT
  bool
  default "$(F_MULTI_UNIT)"

config MULTI_UNIT_ENTRY_POINT
  bool
  default "$(F_MULTI_UNIT_ENTRY_POINT)"

if MULTI_UNIT_ENTRY_POINT || !MULTI_UNIT
  config MMU_UNITS
    string
    default "$(UNIT_NAME)"
endif

if !MULTI_UNIT_ENTRY_POINT
  config UNIT_NAME
    string
    default "$(UNIT_NAME)"

  config MCU_NAME
    string
    default "$(MCU_NAME)"

  config UNIT_INDEX
    int
    default $(shell, echo "${UNIT_INDEX-0}")
endif

comment "$(pad,50,)"
comment "$(pad,50,(\\_/))"
comment "$(pad,50,( *,*))"
comment "$(pad,$(caption_pad),(\")_(\") $(caption))"
comment "$(pad,50,)"

# UI rendering option:
#  y to shows MMU additions menu inline with type
#  n to show as top level menu
config SHOW_MMU_ADDITIONS_WITH_TYPE
  bool
  default n

if MULTI_UNIT_ENTRY_POINT
  config MMU_UNITS
    prompt "MMU unit names"
    help
      Comma-separated list of unit names. Careful: Use only alphanumeric characters.
      If this is the first time configuring mulit-unit from previous single-unit install
      then the first name must be mmu0 because that is how it was configured.
      E.g. "mmu0,mmu1"

      A separate configurator will be run for each MMU after this initial screen is closed

  comment "Shared System Options"
  source "toolheads/Kconfig"        # Toolhead Selection menu
  source "addons/Kconfig"           # Addon Macro Features
  source "Kconfig.options"          # Popular software options
  source "Kconfig.raw"              # Raw access to appropriate parameters
endif

if !MULTI_UNIT_ENTRY_POINT
  source "mmu_types/Kconfig"        # Base MMU type menu
  if !SHOW_MMU_ADDITIONS_WITH_TYPE
    source "mmu_additions/Kconfig"  # MMU Additions/Customization menu (if not inlined with mmu type)
  endif
  source "boards/Kconfig"           # MCU Selection menu
  source "Kconfig.pins"             # Raw pin editing
  source "connection/Kconfig"       # MCU Connection
  if !MULTI_UNIT
    source "toolheads/Kconfig"      # Toolhead Selection menu
    source "addons/Kconfig"         # Addon Macro Features
    source "Kconfig.options"        # Popular software options
  endif
  source "Kconfig.raw"              # Raw access to appropriate parameters
endif
