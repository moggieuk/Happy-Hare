########################################################################################################################
# Happy Hare MMU Software
#
# THIS CONFIG WAS AUTOMATICALLY CREATED FOR [[PARAM_VENDOR]] v[[PARAM_VERSION]] running on a [[PARAM_BOARD_TYPE]] mcu
#
# EDIT THIS FILE BASED ON YOUR SETUP OR PREFERABLY RUN:
#    ~/Happy-Hare/install.sh -i
#
# Copyright (C) 2022-2025  moggieuk#6538 (discord)
#                          moggieuk@hotmail.com
#
# This file may be distributed under the terms of the GNU GPLv3 license.
#
# Goal: Happy Hare MMU hardware config file for a physical MMU unit
#
# (\_/)
# ( *,*)
# (")_(") Happy Hare Ready
#


# ┌──────────────────────────────┐
# │ ███╗   ███╗ ██████╗██╗   ██╗ │
# │ ████╗ ████║██╔════╝██║   ██║ │
# │ ██╔████╔██║██║     ██║   ██║ │
# │ ██║╚██╔╝██║██║     ██║   ██║ │
# │ ██║ ╚═╝ ██║╚██████╗╚██████╔╝ │
# │ ╚═╝     ╚═╝ ╚═════╝ ╚═════╝  │
# └──────────────────────────────┘
#
# Define MCU(s) used to connect with this MMU unit and setup temperature monitoring
#
# Serial connections are defined similar to:
#    serial: /dev/serial/by-id/usb-Klipper_stm32g0b1xx_4F0034000A50425539393020-if00
# CANbus similar to:
#    canbus_uuid: 127081e7e3c6
#
[mcu [[MCU_NAME]]]
[% if CHOICE_MCU_CONNECTION_TYPE_SERIAL %]
serial: [[SERIAL_DEVICE]]
[% elif CHOICE_MCU_CONNECTION_TYPE_CANBUS %]
canbus_uuid: [[CANBUS_UUID]]
[% else %]
#serial:
#canbus_uuid:
[% endif %]

[temperature_sensor MCU_[[UNIT_NAME]]]
sensor_type: temperature_mcu
sensor_mcu: [[MCU_NAME]]

[% if MMU_HAS_BUFFER_MCU %]
[mcu [[MCU_NAME]]_buffer]
[% if CHOICE_MCU_CONNECTION_TYPE_SERIAL %]
serial: [[BUFFER_SERIAL_DEVICE]]
[% elif CHOICE_MCU_CONNECTION_TYPE_CANBUS %]
canbus_uuid: [[BUFFER_CANBUS_UUID]]
[% else %]
#serial:
#canbus_uuid:
[% endif %]

[temperature_sensor MCU_[[UNIT_NAME]]_buffer]
sensor_type: temperature_mcu
sensor_mcu: [[MCU_NAME]]_buffer

[% endif %]


# ┌────────────────────────────────────────────────────────────────────┐
# │ ███╗   ███╗███╗   ███╗██╗   ██╗    ██╗   ██╗███╗   ██╗██╗████████╗ │
# │ ████╗ ████║████╗ ████║██║   ██║    ██║   ██║████╗  ██║██║╚══██╔══╝ │
# │ ██╔████╔██║██╔████╔██║██║   ██║    ██║   ██║██╔██╗ ██║██║   ██║    │
# │ ██║╚██╔╝██║██║╚██╔╝██║██║   ██║    ██║   ██║██║╚██╗██║██║   ██║    │
# │ ██║ ╚═╝ ██║██║ ╚═╝ ██║╚██████╔╝    ╚██████╔╝██║ ╚████║██║   ██║    │
# │ ╚═╝     ╚═╝╚═╝     ╚═╝ ╚═════╝      ╚═════╝ ╚═╝  ╚═══╝╚═╝   ╚═╝    │
# └────────────────────────────────────────────────────────────────────┘
#
# MMU UNIT: A mmu_unit is a physical MMU. It describes the type, characteristics and capabilities (often defined by
# vendor). The name of the unit is used to locate other compoents including it's toolhead steppers, optional encoder
# and espooler. You should create a [mmu_unit XXX] section for every MMU connected to this printer. The XXX
# name should appear in the 'units' on the [mmu_machine] and be used in the mmu_toolhead and accessary name
# as illustrated
#
[mmu_unit [[UNIT_NAME]]]
num_gates: [[PARAM_NUM_GATES]]				# Number of gates/lanes *this* mmu_unit

# MMU Vendor & Version is used to automatically configure some parameters and validate configuration
# If custom set to "Other" and uncomment the additional parameters below
#
# ERCF          1.1  add "s" suffix for Springy, "b" for Binky, "t" for Triple-Decky
#                    e.g. "1.1sb" for v1.1 with Springy mod and Binky encoder
# ERCF          2.0  community edition ERCFv2
# ERCF          3.0  community edition ERCFv3
# Tradrack      1.0  add "e" if encoder is fitted (assumed to be Binky)
# AngryBeaver
# BoxTurtle
# NightOwl
# 3MS
# QuattroBox    1.0
# QuattroBox    2.0  revised LEDs
# 3D Chameleon
# Pico
# MMX
# BTT ViViD
# KMS
# EMU
# Prusa         3.0  NOT YET SUPPORTED - COMING SOON
# Other              Generic setup that may require further customization of 'cad' parameters. See doc in mmu_parameters.cfg
#
vendor:  [[PARAM_VENDOR]]    			# MMU family
version: [[PARAM_VERSION]]				# MMU hardware version number

display_name: [[UNIT_NAME]]   			# Display name of mmu_unit in UI's. Defaults to the vendor name
[% if MMU_HAS_ENCODER %]
encoder:      [[PARAM_ENCODER_NAME]]   			# Name of mmu_encoder if fitted (CAN BE SHARED WITH OTHER MMU_UNITS)
[% endif %]
[% if MMU_HAS_SYNC_FEEDBACK_BUFFER %]
buffer:       [[PARAM_SYNC_FEEDBACK_BUFFER_NAME]]   			# Name of sync-feeback mmu_buffer if fitted (CAN BE SHARED WITH OTHER MMU_UNITS))
[% endif %]
[% if MMU_HAS_ESPOOLER %]
espooler:       [[UNIT_NAME]]   			# Name of mmu_espooler if fitted
[% endif %]


# Full name of environment sensor object for MMU filament storage (displays temp and humidity in UI).
# Leave empty if sensor is not fitted. Polls for "temperature" and "humidity"
# E.g. If you have a section like this: [temperature_sensor MMU_enclosure]
#      Set: environment_sensor: temperature_sensor MMU_enclosure
environment_sensor: [[PARAM_ENVIRONMENT_SENSOR]]

# Full name of filament heater object. Leave empty if heater is not fitted
# E.g. If you have a section like this: [heater_generic MMU_heater]
#      Set: filament_heater: heater_generic MMU_heater
filament_heater: [[PARAM_FILAMENT_HEATER]]

# PER-GATE heaters and environment sensors. Some modular MMU designs have per-gate control (e.g. EMU). For this type of MMU, leave
# 'environment_sensor' and 'filament_heater' empty and define a list of heaters and sensors here. Note the length of the list must
# match the number of gates. Leave this settings empty if defining a single sensor/heater.
environment_sensors:                    # Comma separated list of full environment sensor object names
filament_heaters:                       # Comma separated list of full heater object names
max_concurrent_heaters: 1               # Limit the number of simultaneously active heaters (power/PSU protection)


# PAUL NEW IDEA
### Define the MMU kinematics based on MMU type
##kinematics: [[PARAM_SELECTOR_TYPE]] [[UNIT_NAME]]
##
### The hardware referenced in this kinematics configuration must exist and each have a correctly named configuration section
##[% if PARAM_SELECTOR_TYPE == "LinearServoSelector" %]
##[mmu_linear_servo_selector [[UNIT_NAME]]]
##selector_stepper: [[UNIT_NAME]]_selector_stepper
##selector_servo: [[UNIT_NAME]]_selector_servo
##gear_stepper: [[UNIT_NAME]]_gear_stepper
##
##[% elif PARAM_SELECTOR_TYPE == "LinearSelector" %]
##[mmu_linear_servo_selector [[UNIT_NAME]]]
##selector_stepper: [[UNIT_NAME]]_selector_stepper
##gear_stepper: [[UNIT_NAME]]_gear_stepper
##
##[% elif PARAM_SELECTOR_TYPE == "VirtualSelector" %]
##[mmu_virtual_selector [[UNIT_NAME]]]
##gear_steppers: \
##[% for i in range(0, PARAM_NUM_GATES|int) %]
##    [[UNIT_NAME]]_gear_stepper_[[i]],
##[% endfor %]
##[% endif %]

# ADVANCED: The following attributes are set internally from vendor/version. ONLY uncomment to customize the vendor default
# if you know what you are doing, or for custom ("Other") designs
#
#### PAUL DELETE_ME #selector_type: [[PARAM_SELECTOR_TYPE]]		# E.g. LinearServoSelector (type-A), VirtualSelector (type-B), MacroSelector, RotarySelector, ...
#variable_bowden_lengths: [[PARAM_VARIABLE_BOWDEN_LENGTHS]]		# 1 = If MMU design has different bowden lengths per gate, 0 = bowden length is the same
#variable_rotation_distances: [[PARAM_VARIABLE_ROTATION_DISTANCES]]		# 1 = If MMU design has dissimilar drive/BMG gears, thus rotation distance, 0 = One drive gear (e.g. Tradrack)
#require_bowden_move: [[PARAM_REQUIRE_BOWDEN_MOVE]]			# 1 = If MMU design has bowden move that is included in load/unload, 0 = zero length bowden (skip bowden move)
#filament_always_gripped: [[PARAM_FILAMENT_ALWAYS_GRIPPED]]		# 1 = Filament is always trapped by MMU (most type-B designs), 0 = MMU can release filament
#can_crossload: [[PARAM_CAN_CROSSLOAD]]			# 1 = Possible to preload/eject gate when another has filament loaded, 0 = Not possible
#has_bypass: [[PARAM_HAS_BYPASS]]				# 1 = Integrated bypass gate available, 0 = No integrated bypass; Bypassing only possible via PTFE



# ┌──────────────────────────────────────────────────────────────────────────────────────────────┐
# │ ██████╗ ███████╗ █████╗ ██████╗     ███████╗████████╗███████╗██████╗ ██████╗ ███████╗██████╗ │
# │██╔════╝ ██╔════╝██╔══██╗██╔══██╗    ██╔════╝╚══██╔══╝██╔════╝██╔══██╗██╔══██╗██╔════╝██╔══██╗│
# │██║  ███╗█████╗  ███████║██████╔╝    ███████╗   ██║   █████╗  ██████╔╝██████╔╝█████╗  ██████╔╝│
# │██║   ██║██╔══╝  ██╔══██║██╔══██╗    ╚════██║   ██║   ██╔══╝  ██╔═══╝ ██╔═══╝ ██╔══╝  ██╔══██╗│
# │╚██████╔╝███████╗██║  ██║██║  ██║    ███████║   ██║   ███████╗██║     ██║     ███████╗██║  ██║│
# │ ╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝    ╚══════╝   ╚═╝   ╚══════╝╚═╝     ╚═╝     ╚══════╝╚═╝  ╚═╝│
# └──────────────────────────────────────────────────────────────────────────────────────────────┘
#
# FILAMENT DRIVE / GEAR STEPPER:
# Note about "touch" endstops: Happy Hare provides extremely flexible homing options. The "touch" option
# leverages stallguard and thus requires the appropriate 'diag_pin' and stallguard parameters set on the TMC
# driver section. If you have the diag_pin exposed, it is harmless to define this because they will only
# be used when explicitly needed and configured. Patience is needed to carefully tune stallguard.
#
# Touch option for gear stepper provides the (experimental) automatic detection of the extruder entrance
# (see 'extruder_homing_endstop; mmu_gear_touch' in mmu_parameters.cfg)
#
[tmc2209 stepper_mmu_gear_[[UNIT_NAME]]]
uart_pin: [[PIN_GEAR_UART]]
[% if BOARD_TYPE_EASY_BRD and not BOOL_ENABLE_SELECTOR_TOUCH %]
uart_address: 0 			# Only for old EASY-BRD mcu
[% endif %]
run_current: [[PARAM_GEAR_RUN_CURRENT]]
hold_current: [[PARAM_GEAR_HOLD_CURRENT]]			# Recommend to be small if not using "touch" or move (TMC stallguard)
interpolate: True
sense_resistor: 0.110			# Usually 0.11, 0.15 for BTT TMC2226
stealthchop_threshold: 0		# Spreadcycle has more torque and better at speed

# Uncomment two lines below if you have TMC and want the ability to use filament "touch" homing with gear stepper
#diag_pin: [[PIN_GEAR_DIAG]]				# Set to MCU pin connected to TMC DIAG pin for gear stepper
#driver_SGTHRS: 60			# 255 is most sensitive value, 0 is least sensitive

[stepper_mmu_gear_[[UNIT_NAME]]]
step_pin: [[PIN_GEAR_STEP]]
dir_pin: [[PIN_GEAR_DIR]]
enable_pin: [[PIN_GEAR_ENABLE]]
rotation_distance: [[PARAM_GEAR_ROTATION_DISTANCE]]  		# Typically 22.73 for Bondtech. Overriden by 'mmu_gear_rotation_distance' in mmu_vars.cfg
gear_ratio: [[PARAM_GEAR_GEAR_RATIO]]  			# E.g. ERCFv2 80:20, Tradrack 50:17
microsteps: 16 				# Recommend 16. Increase only if you "step compress" issues when syncing
full_steps_per_rotation: 200		# 200 for 1.8 degree, 400 for 0.9 degree

# Uncomment the two lines below to enable filament "touch" movement option with gear motor
#extra_endstop_pins: tmc2209_stepper_mmu_gear:virtual_endstop
#extra_endstop_names: mmu_gear_touch

[% if VIRTUAL_SELECTOR %]
# ADDITIONAL FILAMENT DRIVE GEAR STEPPERS FOR TYPE-B MMU's ------------------------------------------------------------
# Note that common parameters are inherited from base stepper_mmu_gear, but can be uniquely specified here too
#
[% for i in range(1, PARAM_NUM_GATES|int) %]
# Filament Drive Gear_[[i]] --------------------------
[tmc2209 stepper_mmu_gear_[[UNIT_NAME]]_[[i]]]
uart_pin: [[ (PIN_GEAR_UART_|d)[i] ]]

[stepper_mmu_gear_[[i]]]
step_pin: [[ (PIN_GEAR_STEP_|d)[i] ]]
dir_pin: [[ (PIN_GEAR_DIR_|d)[i] ]]
enable_pin: [[ (PIN_GEAR_ENABLE_|d)[i] ]]
#diag_pin: [[ (PIN_GEAR_DIAG_|d)[i] ]]

[% endfor %]


[% endif %]
[% if MMU_HAS_SELECTOR_STEPPER %]
# ┌────────────────────────────────────────────────────────────────────────────────────────┐
# │███████╗███████╗██╗            ███████╗████████╗███████╗██████╗ ██████╗ ███████╗██████╗ │
# │██╔════╝██╔════╝██║            ██╔════╝╚══██╔══╝██╔════╝██╔══██╗██╔══██╗██╔════╝██╔══██╗│
# │███████╗█████╗  ██║            ███████╗   ██║   █████╗  ██████╔╝██████╔╝█████╗  ██████╔╝│
# │╚════██║██╔══╝  ██║            ╚════██║   ██║   ██╔══╝  ██╔═══╝ ██╔═══╝ ██╔══╝  ██╔══██╗│
# │███████║███████╗███████╗██╗    ███████║   ██║   ███████╗██║     ██║     ███████╗██║  ██║│
# │╚══════╝╚══════╝╚══════╝╚═╝    ╚══════╝   ╚═╝   ╚══════╝╚═╝     ╚═╝     ╚══════╝╚═╝  ╚═╝│
# └────────────────────────────────────────────────────────────────────────────────────────┘
#
# SELECTOR STEPPER:
# Note about "touch" endstops: Happy Hare provides extremely flexible homing options. The "touch" option
# leverages stallguard and thus requires the appropriate 'diag_pin' and stallguard parameters set on the TMC
# driver section. If you have the diag_pin exposed, it is harmless to define this because they will only
# be used when explicitly needed and configured. Patience is needed to carefully tune stallguard.
#
# Touch option for selector stepper provides automatic detection when filament is stuck in the gate
# and subsequent recovery (see 'selector_touch_enable: 1' in mmu_parameters.cfg)
#
# Consult wiki doc if you want to setup selector for stallguard homing instead or physical endstop
#
[tmc2209 stepper_mmu_selector_[[UNIT_NAME]]]
uart_pin: [[PIN_SELECTOR_UART]]
[% if BOARD_TYPE_EASY_BRD %]
uart_address: 1 			# Only for old EASY-BRD mcu
[% endif %]
run_current: [[PARAM_SELECTOR_RUN_CURRENT]]
hold_current: [[PARAM_SELECTOR_HOLD_CURRENT]]			# Can be small if not using "touch" movement (TMC stallguard)
interpolate: True
sense_resistor: 0.110
stealthchop_threshold: 100		# Stallguard "touch" movement (slower speeds) best done with stealthchop

# Uncomment two lines below if you have TMC and want to use selector "touch" movement
[% if BOOL_ENABLE_SELECTOR_TOUCH and PIN_SELECTOR_DIAG|d != "" %]
diag_pin: [[PIN_SELECTOR_DIAG]] 		# Set to MCU pin connected to TMC DIAG pin for selector stepper
driver_SGTHRS: 75			# 255 is most sensitive value, 0 is least sensitive
[% else %]
#diag_pin:     [[PIN_SELECTOR_DIAG]] 		# Set to MCU pin connected to TMC DIAG pin for selector stepper
#driver_SGTHRS: 75			# 255 is most sensitive value, 0 is least sensitive
[% endif %]

[stepper_mmu_selector_[[UNIT_NAME]]]
step_pin: [[PIN_SELECTOR_STEP]]
dir_pin: [[PIN_SELECTOR_DIR]]
enable_pin: [[PIN_SELECTOR_ENABLE]]
rotation_distance: [[PARAM_SELECTOR_ROTATION_DISTANCE]]
gear_ratio: [[PARAM_SELECTOR_GEAR_RATIO]]
microsteps: 16 				# Don't need high fidelity
full_steps_per_rotation: 200		# 200 for 1.8 degree, 400 for 0.9 degree
endstop_pin: [[PIN_SELECTOR_ENDSTOP]]			# Selector microswitch
endstop_name: [[PARAM_SELECTOR_ENDSTOP_NAME]]
#homing_retract_dist: 0			# Uncomment ONLY if default endstop above is using stallguard

# Uncomment two lines below to give option of selector "touch" movement
[% if BOOL_ENABLE_SELECTOR_TOUCH and PIN_SELECTOR_DIAG|d != "" %]
extra_endstop_pins: tmc2209_stepper_mmu_selector:virtual_endstop
extra_endstop_names: mmu_sel_touch
[% else %]
#extra_endstop_pins: tmc2209_stepper_mmu_selector:virtual_endstop
#extra_endstop_names: mmu_sel_touch
[% endif %]



[% endif %]
[% if MMU_HAS_SELECTOR_SERVO %]
# ┌───────────────────────────────────────────────────────────────────────────┐
# │ ███████╗███████╗██╗            ███████╗███████╗██████╗ ██╗   ██╗ ██████╗  │
# │ ██╔════╝██╔════╝██║            ██╔════╝██╔════╝██╔══██╗██║   ██║██╔═══██╗ │
# │ ███████╗█████╗  ██║            ███████╗█████╗  ██████╔╝██║   ██║██║   ██║ │
# │ ╚════██║██╔══╝  ██║            ╚════██║██╔══╝  ██╔══██╗╚██╗ ██╔╝██║   ██║ │
# │ ███████║███████╗███████╗██╗    ███████║███████╗██║  ██║ ╚████╔╝ ╚██████╔╝ │
# │ ╚══════╝╚══════╝╚══════╝╚═╝    ╚══════╝╚══════╝╚═╝  ╚═╝  ╚═══╝   ╚═════╝  │
# └───────────────────────────────────────────────────────────────────────────┘
#
# SELECTOR SERVO: Basic servo PWM setup. Note that if these values are changed then any calibrated angles will also change
#
[mmu_servo [[UNIT_NAME]]]
pin: [[PIN_SELECTOR_SERVO]]
maximum_servo_angle: [[PARAM_SERVO_MAX_ANGLE]]
minimum_pulse_width: [[PARAM_SERVO_MIN_PULSE_WIDTH]]
maximum_pulse_width: [[PARAM_SERVO_MAX_PULSE_WIDTH]]



[% endif %]
# ┌─────────────────────────────────────────────────────────────┐
# │ ███████╗███████╗███╗   ██╗███████╗ ██████╗ ██████╗ ███████╗ │
# │ ██╔════╝██╔════╝████╗  ██║██╔════╝██╔═══██╗██╔══██╗██╔════╝ │
# │ ███████╗█████╗  ██╔██╗ ██║███████╗██║   ██║██████╔╝███████╗ │
# │ ╚════██║██╔══╝  ██║╚██╗██║╚════██║██║   ██║██╔══██╗╚════██║ │
# │ ███████║███████╗██║ ╚████║███████║╚██████╔╝██║  ██║███████║ │
# │ ╚══════╝╚══════╝╚═╝  ╚═══╝╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝ │
# └─────────────────────────────────────────────────────────────┘
#
# MMU FILAMAENT SENSORS: Define the pins for optional sensors in the filament path. A single [mmu_sensors] section is
# defined to cover ALL the gates of the mmu_unit and gate numbers always start with 0. All but the pre-gate sensors will
# be automatically# setup as both endstops (for homing) and sensors for visibility purposes
#
#   'pre_gate_switch_pin_X'  .. 'mmu_pre_gate_X' sensor detects filament at entry to MMU. X=gate number (0..N)
#   'post_gear_switch_pin_X' .. 'mmu_gear_X' sensor on exit of each gate. Common on type-B but not type-A
#   'gate_switch_pin'        .. 'mmu_gate' shared exit sensor detects filament past all gates (aka hub sensor)
#
# Pin configuration is flexible: Simply define pins for any sensor you want to enable, if pin is empty it will be
# ignored so no need to comment out what you are not using.
#
[mmu_sensors [[UNIT_NAME]]]
[% for i in range(0, PARAM_NUM_GATES|int) %]
pre_gate_switch_pin_[[i]]:  [[ (PIN_PRE_GATE_|d)[i] ]]
[% endfor %]

[% for i in range(0, PARAM_NUM_GATES|int) %]
post_gear_switch_pin_[[i]]: [[ (PIN_POST_GEAR_|d)[i] ]]
[% endfor %]

# This is a shared sensor by all gates. On type-B designs it is often on the exit of the filament combiner (hub)
#
gate_switch_pin:        [[PIN_GATE_SENSOR]]



[% if MMU_HAS_ESPOOLER %]
# ┌────────────────────────────────────────────────────────────────────┐
# │ ███████╗███████╗██████╗  ██████╗  ██████╗ ██╗     ███████╗██████╗  │
# │ ██╔════╝██╔════╝██╔══██╗██╔═══██╗██╔═══██╗██║     ██╔════╝██╔══██╗ │
# │ █████╗  ███████╗██████╔╝██║   ██║██║   ██║██║     █████╗  ██████╔╝ │
# │ ██╔══╝  ╚════██║██╔═══╝ ██║   ██║██║   ██║██║     ██╔══╝  ██╔══██╗ │
# │ ███████╗███████║██║     ╚██████╔╝╚██████╔╝███████╗███████╗██║  ██║ │
# │ ╚══════╝╚══════╝╚═╝      ╚═════╝  ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═╝ │
# └────────────────────────────────────────────────────────────────────┘
#
# ESPOOLER: An espooler controls DC motors (typically N20) that are able to rewind a filament spool and optionally provide
# forward assist to overcome spooler rotation friction. This should define pins for each of the gates on your mmu
# starting with '_0'.
#
[mmu_espooler [[UNIT_NAME]]]
pwm: 1						# 1=PWM control (typical), 0=digital on/off control
hardware_pwm: 0					# See klipper doc
cycle_time: 0.100				# See klipper doc
scale: 1					# Scales the PWM output range
value: 0					# See klipper doc
shutdown_value: 0				# See klipper doc

# Pins (note that empty pins will be ignored and can be left blank)
# respool_motor_pin is PWM (or digital) pin for rewind/respool movement
# assist_motor_pin is PWM (or digital) pin for forward motor movement
# enable_motor_pin is  digital output for Afc mcu (not used on most other mcus)
# assist_trigger_pin is tigger pin for sensing need to assist during print
#
[% for i in range(0, PARAM_NUM_GATES|int) %]
respool_motor_pin_[[i]]:  [[ (PIN_ESPOOLER_RWD_|d)[i] ]]
assist_motor_pin_[[i]]:   [[ (PIN_ESPOOLER_FWD_|d)[i] ]]
[% if HAS_ESPOOLER_ENABLE_PIN %]
enable_motor_pin_[[i]]:   [[ (PIN_ESPOOLER_EN_|d)[i] ]]
[% endif %]
assist_trigger_pin_[[i]]: [[ (PIN_ESPOOLER_TRIG_|d)[i] ]]

[% endfor %]


[% endif %]
[% if MMU_HAS_LEDS %]
# ┌────────────────────────────────┐
# │██╗     ███████╗██████╗ ███████╗│
# │██║     ██╔════╝██╔══██╗██╔════╝│
# │██║     █████╗  ██║  ██║███████╗│
# │██║     ██╔══╝  ██║  ██║╚════██║│
# │███████╗███████╗██████╔╝███████║│
# │╚══════╝╚══════╝╚═════╝ ╚══════╝│
# └────────────────────────────────┘
#
# LED SUPPORT: Define mmu leds, both the "neopixel" config and [mmu_led] to define their purpose
#
[neopixel [[UNIT_NAME]]_leds]
pin: [[PIN_NEOPIXEL]]
chain_count: [[PARAM_CHAIN_COUNT]]			# Count much be feasible e.g. N-leds per gate plus extra segments
color_order: [[PARAM_COLOR_ORDER]]		# Set based on your particular neopixel specification (can be comma separated list)

# MMU LED EFFECT SEGMENTS ----------------------------------------------------------------------------------------------
# Define neopixel LEDs for your MMU. The chain_count must be large enough for your desired ranges:
#   exit   .. this set of LEDs, one for every gate, usually would be mounted at the exit point of the gate
#   entry  .. this set of LEDs, one for every gate, could be mounted at the entry point of filament into this MMU/buffer
#   status .. these LED. represents the status of the MMU (and selected filament). More than one status LED is possible
#   logo   .. these LEDs don't change during operation and are designed lighting a logo. Multiple logo LEDs are possible
#
# Note that all sets are optional. You can opt to just have the 'exit' set for example. The advantage to having
# both entry and exit LEDs is, for example, so that 'entry' can display gate status while 'exit' displays the color
#
# The animation effects requires the installation of Julian Schill's awesome LED effect module otherwise the LEDs
# will be static:
#   https://github.com/julianschill/klipper-led_effect
#
# LED's are indexed in the chain from 1..N. Thus to set up LED's on 'exit' and a single 'status' LED on a 4 gate MMU:
#
#    exit_leds:   neopixel:mmu_leds (1,2,3,4)
#    status_leds: neopixel:mmu_leds (5)
#
# In this example no 'entry' set is configured. Note that constructs like "mmu_leds (1-3,4)" are also valid
#
# The range is completely flexible and can be comprised of different led strips, individual LEDs, or combinations of
# both on different pins. In addition, the ordering is flexible based on your wiring, thus (1-4) and (4-1) both
# represent the same LED range but mapped to increasing or decreasing gates respectively. E.g if you have two Box
# Turtle MMUs, one with a chain of LEDs wired in reverse order and another with individual LEDs, to define 8 exit LEDs:
#
#   exit_leds: neopixel:bt_1 (4-1)
#              neopixel:bt_2a
#              neopixel:bt_2b
#              neopixel:bt_2c
#              neopixel:bt_2d
#
# Note the use of separate lines for each part of the definition,
#
# ADVANCED: Happy Hare provides a convenience wrapper [mmu_led_effect] that not only creates an effect on each of the
# [mmu_leds] specified segments as a whole but also each individual LED for atomic control. See mmu_leds.cfg for examples
#
[mmu_leds [[UNIT_NAME]]]
exit_leds:   [[PARAM_EXIT_LEDS]]
entry_leds:  [[PARAM_ENTRY_LEDS]]
status_leds: [[PARAM_STATUS_LEDS]]
logo_leds:   [[PARAM_LOGO_LEDS]]
frame_rate: 24

# Default effects for LED segments when not providing action status
#    off              - LED's off
#    on               - LED's white
#    gate_status      - indicate gate availability / status            (printer.mmu.gate_status)
#    filament_color   - display filament color defined in gate map     (printer.mmu.gate_color_rgb)
#    slicer_color     - display slicer defined set color for each gate (printer.mmu.slicer_color_rgb)
#   (r,g,b)           - display static r,g,b color e.g. "0,0,0.3" for dim blue
#    _effect_         - display the named led effect
#
# PAUL there is a consistency case to be made for this section to be moved to mmu_parameters (or move moved to objects in mmu_hardwared?)
enabled:       [[PARAM_ENABLED]]			# True = LEDs are enabled at startup (MMU_LED can control), False = Disabled
animation:     [[PARAM_ANIMATION]]			# True = Use led-animation-effects, False = Static LEDs
exit_effect:   gate_status		#    off|gate_status|filament_color|slicer_color|r,g,b|_effect_
entry_effect:  filament_color		#    off|gate_status|filament_color|slicer_color|r,g,b|_effect_
status_effect: filament_color		# on|off|gate_status|filament_color|slicer_color|r,g,b|_effect_
logo_effect:   (0, 0, 0.3)		#    off                                        |r,g,b|_effect_
white_light:   (1, 1, 1)		# RGB color for static white light
black_light:   (.01, 0, .02)		# RGB color used to represent "black" (filament)
empty_light:   (0, 0, 0)		# RGB color used to represent empty gate

# Default effects (animation: True) / static rbg (animation False) to apply to actions
#   effect_name, (r,b,g)
#
# IMPORTANT: Effects must be from [mmu_led_effects] set defined in mmu_leds.cfg
#
effect_loading:            mmu_blue_clockwise_slow, (0, 0, 0.4)
effect_loading_extruder:   mmu_blue_clockwise_fast, (0, 0, 1)
effect_unloading:          mmu_blue_anticlock_slow, (0, 0, 0.4)
effect_unloading_extruder: mmu_blue_anticlock_fast, (0, 0, 1)
effect_heating:            mmu_breathing_red,       (0.3, 0, 0)
effect_selecting:          mmu_white_fast,          (0.2, 0.2, 0.2)
effect_checking:           mmu_white_fast,          (0.8, 0.8, 0.8)
effect_initialized:        mmu_rainbow,             (0.5, 0.2, 0)
effect_error:              mmu_strobe,              (1, 0, 0)
effect_complete:           mmu_sparkle,             (0.3, 0.3, 0.3)
effect_gate_selected:      mmu_static_blue,         (0, 0, 1)
effect_gate_available:     mmu_static_green,        (0, 0.5, 0)
effect_gate_available_sel: mmu_ready_green,         (0, 0.75, 0)
effect_gate_unknown:       mmu_static_orange,       (0.5, 0.2, 0)
effect_gate_unknown_sel:   mmu_ready_orange,        (0.75, 0.3, 0)
effect_gate_empty:         mmu_static_black,        (0, 0, 0)
effect_gate_empty_sel:     mmu_ready_orange2,       (0.1, 0.04, 0)



[% endif %]
[% if MMU_HAS_SYNC_FEEDBACK_BUFFER %]
# ┌───────────────────────────────────────────────────┐
# │ ██████╗ ██╗   ██╗███████╗███████╗███████╗██████╗  │
# │ ██╔══██╗██║   ██║██╔════╝██╔════╝██╔════╝██╔══██╗ │
# │ ██████╔╝██║   ██║█████╗  █████╗  █████╗  ██████╔╝ │
# │ ██╔══██╗██║   ██║██╔══╝  ██╔══╝  ██╔══╝  ██╔══██╗ │
# │ ██████╔╝╚██████╔╝██║     ██║     ███████╗██║  ██║ │
# │ ╚═════╝  ╚═════╝ ╚═╝     ╚═╝     ╚══════╝╚═╝  ╚═╝ │
# └───────────────────────────────────────────────────┘
#
# SYNC FEEDBACK SENSOR/BUFFER: Sync feedback sensors often called "buffers" are used to synchronize MMU gear stepper
# movement with the extruder. They will typically have a tension switch (most important) or both tension and compression.
# Note that compression switch is useful for use as a endstop to detect hitting the extruder entrance
#
#   'sync_feedback_tension_pin'     .. pin for switch activated when filament is under tension
#   'sync_feedback_compression_pin' .. pin for switch activated when filament is under compression
#
# Pin configuration is flexible: Simply define pins for any sensor you want to enable, if pin is empty it will be
# ignored so no need to comment out what you are not using
#
[mmu_buffer [[UNIT_NAME]]]
sync_feedback_tension_pin:     [[PIN_SYNC_FEEDBACK_TENSION]]
sync_feedback_compression_pin: [[PIN_SYNC_FEEDBACK_COMPRESSION]]

# Proportional sync feedback sensor configuration. Leave empty if not fitted.
# (if you have a proportional sensor the sync_feedback_tension_pin and sync_feedback_compression_pin would likely be empty)
#
sync_feedback_analog_pin: [[PIN_SYNC_FEEDBACK_ANALOG]]			# The ADC pin where the proportional filament pressure sensor is installed
sync_feedback_analog_max_compression: 1		# Raw sensor reading at max filament compression (buffer squeezed)
sync_feedback_analog_max_tension: 0		# Raw sensor reading at max filament tension (buffer expanded)
sync_feedback_analog_neutral_point: 0.50	# Biasing of neutral point (sensor value 0). Normally close to 0.5



[% endif %]
[% if MMU_HAS_ENCODER %]
# ┌─────────────────────────────────────────────────────────────┐
# │ ███████╗███╗   ██╗ ██████╗ ██████╗ ██████╗ ███████╗██████╗  │
# │ ██╔════╝████╗  ██║██╔════╝██╔═══██╗██╔══██╗██╔════╝██╔══██╗ │
# │ █████╗  ██╔██╗ ██║██║     ██║   ██║██║  ██║█████╗  ██████╔╝ │
# │ ██╔══╝  ██║╚██╗██║██║     ██║   ██║██║  ██║██╔══╝  ██╔══██╗ │
# │ ███████╗██║ ╚████║╚██████╗╚██████╔╝██████╔╝███████╗██║  ██║ │
# │ ╚══════╝╚═╝  ╚═══╝ ╚═════╝ ╚═════╝ ╚═════╝ ╚══════╝╚═╝  ╚═╝ │
# └─────────────────────────────────────────────────────────────┘
#
# ENCODER: measures distance, monitors for runout and clogging and constantly calculates % flow rate
# Note that the encoder_resolution set here is a default to get started. It will be correcly set after calibration
# with the value stored in mmu_vars.cfg
#
# The encoder resolution will be calibrated but it needs a default approximation
# If BMG gear based:
#   resolution = bmg_circumfrance / (2 * teeth)
# 24 / (2 * 17) = 0.7059 for TRCT5000 based sensor
# 24 / (2 * 12) = 1.0 for Binky with 12 tooth disc
#
[mmu_encoder [[UNIT_NAME]]]
encoder_pin: [[PIN_ENCODER]]
encoder_resolution: [[PARAM_ENCODER_RESOLUTION]]		# This is just a starter value. Overriden by calibrated 'mmu_encoder_resolution' in mmm_vars.cfg
desired_headroom: 5.0		# The clog/runout headroom that MMU attempts to maintain (closest point to triggering runout)
average_samples: 4		# The "damping" effect of last measurement (higher value means slower automatic clog_length reduction)
flowrate_samples: 20		# How many "movements" of the extruder to measure average flowrate over



[% endif %]
# ┌──────────────────────────────────────────────────────────────────────────────────────────────────────┐
# │ ███╗   ███╗██╗███████╗ ██████╗    ██╗  ██╗ █████╗ ██████╗ ██████╗ ██╗    ██╗ █████╗ ██████╗ ███████╗ │
# │ ████╗ ████║██║██╔════╝██╔════╝    ██║  ██║██╔══██╗██╔══██╗██╔══██╗██║    ██║██╔══██╗██╔══██╗██╔════╝ │
# │ ██╔████╔██║██║███████╗██║         ███████║███████║██████╔╝██║  ██║██║ █╗ ██║███████║██████╔╝█████╗   │
# │ ██║╚██╔╝██║██║╚════██║██║         ██╔══██║██╔══██║██╔══██╗██║  ██║██║███╗██║██╔══██║██╔══██╗██╔══╝   │
# │ ██║ ╚═╝ ██║██║███████║╚██████╗    ██║  ██║██║  ██║██║  ██║██████╔╝╚███╔███╔╝██║  ██║██║  ██║███████╗ │
# │ ╚═╝     ╚═╝╚═╝╚══════╝ ╚═════╝    ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝  ╚══╝╚══╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝ │
# └──────────────────────────────────────────────────────────────────────────────────────────────────────┘
#
# Define any additional hardware for this MMU unit, e.g. heaters, enclosure temperature probes, etc
#
# EXCLUDE FROM CONFIG BUILDER -- IMPORTANT do not alter or remove this line. Config below is never upgraded
#
[[PARAM_MISC_HARDWARE]]
