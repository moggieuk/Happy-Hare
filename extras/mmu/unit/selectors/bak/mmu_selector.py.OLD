# Happy Hare MMU Software
#
# Copyright (C) 2022-2026  moggieuk#6538 (discord)
#                          moggieuk@hotmail.com
#
# Goal: Implementation of various selector variations:
#
# Rotary Selector
# - Rotary Selector for 3D Chamelon using stepper selection
#   without servo
#
# Servo Selector
# - Servo based Selector for PicoMMU and clones
#
# Indexed Selector
# - Stepper based Selector for ViViD with per-gate index sensors
#
#
# Implements commands (selector dependent):
#    MMU_CALIBRATE_SELECTOR
#    MMU_SOAKTEST_SELECTOR
#    MMU_SERVO
#    MMU_GRIP
#    MMU_RELEASE
#
#
# (\_/)
# ( *,*)
# (")_(") Happy Hare Ready
#
# This file may be distributed under the terms of the GNU GPLv3 license.
#
import logging, traceback

# Klipper imports
from ....homing        import Homing, HomingMove

# Happy Hare imports
from ...mmu_constants   import *
from ...mmu_utils       import MmuError
from ..mmu_calibrator   import CALIBRATED_SELECTOR
from .mmu_base_selector import PhysicalSelector


################################################################################
# Rotary Selector
# Implements Rotary Selector for type-A MMU's that uses stepper controlled
# rail[0] on mmu toolhead (3D Chameleon)
#
# 'filament_always_gripped' alters operation:
#   0 (default) - Lazy gate selection, occurs when asked to grip filament
#   1           - Gripped immediately on selection and will not release
#
# Implements commands:
#   MMU_CALIBRATE_SELECTOR
#   MMU_SOAKTEST_SELECTOR
#   MMU_GRIP    - realign with selected gate
#   MMU_RELEASE - move between gates to release filament
################################################################################

class RotarySelector(PhysicalSelector):

    def __init__(self, config, mmu_unit, params):
        super().__init__(config, mmu_unit, params)

        # Process config
        self.selector_move_speed = config.getfloat('selector_move_speed', 200, minval=1.)
        self.selector_homing_speed = config.getfloat('selector_homing_speed', 100, minval=1.)

        # Gate direction and "release" position if 'filament_always_gripped: 0'
        self.selector_gate_directions = list(config.getintlist('selector_cad_directions', [1, 1, 0, 0]))
        self.selector_release_gates = list(config.getintlist('selector_release_gates', [2, 3, 0, 1]))

        # To simplfy config CAD related parameters are set based on vendor and version setting
        #
        #  cad_gate0_pos          - approximate distance from endstop to first gate
        #  cad_gate_width         - width of each gate
        #  cad_last_gate_offset   - distance from end of travel to last gate
        #
        # Chameleon defaults
        self.cad_gate0_pos = 4.0
        self.cad_gate_width = 25.
        self.cad_last_gate_offset = 2.
        self.cad_bypass_offset = 0 # Doesn't have bypass
        self.cad_selector_tolerance = 15.

        # But still allow all CAD parameters to be customized
        self.cad_gate0_pos = config.getfloat('cad_gate0_pos', self.cad_gate0_pos, minval=0.)
        self.cad_gate_width = config.getfloat('cad_gate_width', self.cad_gate_width, above=0.)
        self.cad_last_gate_offset = config.getfloat('cad_last_gate_offset', self.cad_last_gate_offset, above=0.)
        self.cad_selector_tolerance = config.getfloat('cad_selector_tolerance', self.cad_selector_tolerance, above=0.)

        # Register GCODE commands specific to this module
        self.register_mux_command('MMU_CALIBRATE_SELECTOR', self.cmd_MMU_CALIBRATE_SELECTOR, desc=self.cmd_MMU_CALIBRATE_SELECTOR_help)
        self.register_mux_command('MMU_GRIP', self.cmd_MMU_GRIP, desc=self.cmd_MMU_GRIP_help)
        self.register_mux_command('MMU_RELEASE', self.cmd_MMU_RELEASE, desc=self.cmd_MMU_RELEASE_help)

    # Selector "Interface" methods ---------------------------------------------

    def reinit(self):
        self.grip_state = FILAMENT_DRIVE_STATE

    def handle_connect(self):
        super().handle_connect()

        self.selector_rail = self.mmu_toolhead.get_kinematics().rails[0]
        self.selector_stepper = self.selector_rail.steppers[0]

        # Adjust selector rail limits now we know the config
        self.selector_rail.position_min = -1
        self.selector_rail.position_max = self._get_max_selector_movement()
        self.selector_rail.homing_speed = self.selector_homing_speed
        self.selector_rail.second_homing_speed = self.selector_homing_speed / 2.
        self.selector_rail.homing_retract_speed = self.selector_homing_speed
        self.selector_rail.homing_positive_dir = False

        # Have an endstop (most likely stallguard)?
        endstops = self.selector_rail.get_endstops()
        self.has_endstop = bool(endstops) and endstops[0][0].__class__.__name__ != "MockEndstop"

        # Load selector offsets (calibration set with MMU_CALIBRATE_SELECTOR) -------------------------------
        self.var_manager.upgrade(VARS_MMU_SELECTOR_OFFSETS, self.mmu_unit.name) # v3 upgrade
        self.selector_offsets = self.var_manager.get(VARS_MMU_SELECTOR_OFFSETS, None, namespace=self.mmu_unit.name)
        if self.selector_offsets:
            # Ensure list size
            if len(self.selector_offsets) == self.mmu_unit.num_gates:
                self.mmu.log_debug("Loaded saved selector offsets: %s" % self.selector_offsets)
            else:
                self.mmu.log_error("Incorrect number of gates specified in %s. Adjusted length" % VARS_MMU_SELECTOR_OFFSETS)
                self.selector_offsets = self._ensure_list_size(self.selector_offsets, self.mmu_unit.num_gates)

            if not any(x == -1 for x in self.selector_offsets):
                self.calibrator.mark_calibrated(self.calibrator.CALIBRATED_SELECTOR)
        else:
            self.mmu.log_always("Warning: Selector offsets not found in mmu_vars.cfg. Probably not calibrated")
            self.selector_offsets = [-1] * self.mmu_unit.num_gates
        self.var_manager.set(VARS_MMU_SELECTOR_OFFSETS, self.selector_offsets, namespace=self.mmu_unit.name)

    def _ensure_list_size(self, lst, size, default_value=-1):
        lst = lst[:size]
        lst.extend([default_value] * (size - len(lst)))
        return lst

    def home(self, force_unload = None):
        if self.mmu.check_if_bypass(): return
        with self.mmu.wrap_action(ACTION_HOMING):
            self.mmu.log_info("Homing MMU...")
            if force_unload is not None:
                self.mmu.log_debug("(asked to %s)" % ("force unload" if force_unload else "not unload"))
            if force_unload is True:
                # Forced unload case for recovery
                self.mmu.unload_sequence(check_state=True)
            elif force_unload is False and self.mmu.filament_pos != FILAMENT_POS_UNLOADED:
                # Automatic unload case
                self.mmu.unload_sequence()
            self._home_selector()

    # Actual gate selection can be delayed (if not forcing grip) until the
    # filament_drive/release to reduce selector movement
    def select_gate(self, gate):
        if gate != self.mmu.gate_selected:
            with self.mmu.wrap_action(ACTION_SELECTING):
                if self.mmu_unit.filament_always_gripped:
                    self._grip(self.local_gate(gate))

    def restore_gate(self, gate):
        gate_pos = self.var_manager.get(VARS_MMU_SELECTOR_GATE_POS, None, namespace=self.mmu_unit.name)
        if gate_pos is not None:
            self.set_position(self.selector_offsets[gate_pos])
            if self.local_gate(gate) == gate_pos:
                self.grip_state = FILAMENT_DRIVE_STATE
            else:
                self.grip_state = FILAMENT_RELEASE_STATE
        else:
            self.grip_state = FILAMENT_UNKNOWN_STATE

    def filament_drive(self):
        self._grip(self.local_gate(self.mmu.gate_selected))

    def filament_release(self, measure=False):
        if not self.mmu_unit.filament_always_gripped:
            self._grip(self.local_gate(self.mmu.gate_selected), release=True)
        return 0. # Fake encoder movement

    # Note there is no separation of gate selection and grip/release with this type of selector
    def _grip(self, gate, release=False):
        lgate = self.local_gate(gate)
        if lgate >= 0:
            if release:
                release_pos = self.selector_offsets[self.selector_release_gates[lgate]]
                self.mmu.log_trace("Setting selector to filament release position at position: %.1f" % release_pos)
                self._position(release_pos)
                self.grip_state = FILAMENT_RELEASE_STATE

                # Precaution to ensure correct postion/gate restoration on restart
                self.var_manager.set(VARS_MMU_SELECTOR_GATE_POS, self.selector_release_gates[lgate], write=True, namespace=self.mmu_unit.name)
            else:
                grip_pos = self.selector_offsets[lgate]
                self.mmu.log_trace("Setting selector to filament grip position at position: %.1f" % grip_pos)
                self._position(grip_pos)
                self.grip_state = FILAMENT_DRIVE_STATE

                # Precaution to ensure correct postion/gate restoration on restart
                self.var_manager.set(VARS_MMU_SELECTOR_GATE_POS, lgate, write=True, namespace=self.mmu_unit.name)

            # Ensure gate filament drive is in the correct direction
            self.mmu_toolhead.get_kinematics().rails[1].set_direction(self.selector_cad_directions[lgate])
            self.mmu.movequeues_wait()
        else:
            self.grip_state = FILAMENT_UNKNOWN_STATE

    def get_filament_grip_state(self):
        return self.grip_state

    def disable_motors(self):
        stepper_enable = self.printer.lookup_object('stepper_enable')
        se = stepper_enable.lookup_enable(self.selector_stepper.get_name())
        se.motor_disable(self.mmu_toolhead.get_last_move_time())
        self.is_homed = False

    def enable_motors(self):
        stepper_enable = self.printer.lookup_object('stepper_enable')
        se = stepper_enable.lookup_enable(self.selector_stepper.get_name())
        se.motor_enable(self.mmu_toolhead.get_last_move_time())

    def buzz_motor(self, motor):
        if motor == "selector":
            pos = self.mmu_toolhead.get_position()[0]
            self.move(None, pos + 5, wait=False)
            self.move(None, pos - 5, wait=False)
            self.move(None, pos, wait=False)
        else:
            return False
        return True

    def get_status(self, eventtime):
        status = super().get_status(eventtime)
        status.update({
            'grip': "Gripped" if self.grip_state == FILAMENT_DRIVE_STATE else "Released",
        })
        return status

    def get_mmu_status_config(self):
        msg = "\nSelector is NOT HOMED. " if not self.is_homed else ""
        msg += "Filament is %s" % ("GRIPPED" if self.grip_state == FILAMENT_DRIVE_STATE else "RELEASED")
        return msg

    def set_test_config(self, gcmd):
        self.selector_move_speed = gcmd.get_float('SELECTOR_MOVE_SPEED', self.selector_move_speed, minval=1.)
        self.selector_homing_speed = gcmd.get_float('SELECTOR_HOMING_SPEED', self.selector_homing_speed, minval=1.)

    def get_test_config(self):
        msg = "\n\nSELECTOR:"
        msg += "\nselector_move_speed = %.1f" % self.selector_move_speed
        msg += "\nselector_homing_speed = %.1f" % self.selector_homing_speed
        return msg

    def get_uncalibrated_gates(self, check_gates):
        return [lgate + self.mmu_unit.first_gate for lgate, value in enumerate(self.selector_offsets) if value == -1 and lgate + self.mmu_unit.first_gate in check_gates]

    # Internal Implementation --------------------------------------------------

    cmd_MMU_GRIP_help = "Grip filament in current gate"
    def cmd_MMU_GRIP(self, gcmd):
        if self.mmu.gate_selected >= 0:
            self.filament_drive()

    cmd_MMU_RELEASE_help = "Ungrip filament in current gate"
    def cmd_MMU_RELEASE(self, gcmd):
        if self.mmu.gate_selected >= 0:
            if not self.mmu_unit.filament_always_gripped:
                self.filament_release()
            else:
                self.mmu.log_error("Selector configured to not allow filament release")

    cmd_MMU_CALIBRATE_SELECTOR_help = "Calibration of the selector positions or postion of specified gate"
    cmd_MMU_CALIBRATE_SELECTOR_param_help = (
        "MMU_CALIBRATE_SELECTOR: %s\n" % cmd_MMU_CALIBRATE_SELECTOR_help
        + "UNIT   = #(int)\n"
        + "GATE   = #(int) Optional, default all gates on unit\n"
        + "SAVE   = [0|1]\n"
        + "SINGLE = [0|1]\n"
        + "QUICK  = [0|1]\n"
    )
    def cmd_MMU_CALIBRATE_SELECTOR(self, gcmd):
        self.mmu.log_to_file(gcmd.get_commandline())
        if self.mmu.check_if_disabled(): return

        save = gcmd.get_int('SAVE', 1, minval=0, maxval=1)
        single = gcmd.get_int('SINGLE', 0, minval=0, maxval=1)
        quick = gcmd.get_int('QUICK', 0, minval=0, maxval=1)
        gate = gcmd.get_int('GATE', 0, minval=0, maxval=self.mmu_unit.num_gates - 1)

        if help:
            self.mmu.log_always(self.mmu.format_help(self.cmd_MMU_CALIBRATE_SELECTOR_param_help), color=True)
            return

        try:
            self.mmu.calibrating = True
            self.mmu.reinit()
            successful = False

            if self.has_endstop and not quick:
                successful = self._calibrate_selector(gate, extrapolate=not single, save=save)
            else:
                self.mmu.log_always("%s - will calculate gate offsets from cad_gate0_offset and cad_gate_width" % ("Quick method" if quick else "No endstop configured"))
                self.selector_offsets = [round(self.cad_gate0_pos + i * self.cad_gate_width, 1) for i in range(self.mmu_unit.num_gates)]
                self.var_manager.set(VARS_MMU_SELECTOR_OFFSETS, self.selector_offsets, write=True, namespace=self.mmu_unit.name)
                successful = True

            if not any(x == -1 for x in self.selector_offsets):
                self.calibrator.mark_calibrated(self.calibrator.CALIBRATED_SELECTOR)

            # If not fully calibrated turn off the selector stepper to ease next step, else activate by homing
            if successful and self.calibrator.check_calibrated(self.calibrator.CALIBRATED_SELECTOR):
                self.mmu.log_always("Selector calibration complete")
                self.mmu.select_tool(0)
            else:
                self.mmu.motors_onoff(on=False, motor="selector")

        except MmuError as ee:
            self.mmu.handle_mmu_error(str(ee))
        finally:
            self.mmu.calibrating = False

    def _get_max_selector_movement(self, gate=-1):
        n = gate if gate >= 0 else self.mmu_unit.num_gates - 1

        max_movement = self.cad_gate0_pos + (n * self.cad_gate_width)
        max_movement += self.cad_last_gate_offset if gate in [TOOL_GATE_UNKNOWN] else 0.
        max_movement += self.cad_selector_tolerance
        return max_movement

    # Manual selector offset calibration
    def _calibrate_selector(self, gate, extrapolate=True, save=True):
        max_movement = self._get_max_selector_movement(gate)
        self.mmu.log_always("Measuring the selector position for gate %d..." % gate)
        traveled, found_home = self.measure_to_home()

        # Test we actually homed
        if not found_home:
            self.mmu.log_error("Selector didn't find home position")
            return False

        # Warn and don't save if the measurement is unexpected
        if traveled > max_movement:
            self.mmu.log_always("Selector move measured %.1fmm. More than the anticipated maximum of %.1fmm. Save disabled\nIt is likely that your basic MMU dimensions are incorrect in mmu_parameters.cfg. Check vendor/version and optional 'cad_*' parameters" % (traveled, max_movement))
            save = 0
        else:
            self.mmu.log_always("Selector move measured %.1fmm" % traveled)

        if save:
            self.selector_offsets[gate] = round(traveled, 1)
            if extrapolate and gate == self.mmu_unit.num_gates - 1 and self.selector_offsets[0] > 0:
                # Distribute selector spacing based on measurements of first and last gate
                spacing = (self.selector_offsets[-1] - self.selector_offsets[0]) / (self.mmu_unit.num_gates - 1)
                self.selector_offsets = [round(self.selector_offsets[0] + i * spacing, 1) for i in range(self.mmu_unit.num_gates)]
            elif extrapolate:
                # Distribute using cad spacing
                self.selector_offsets = [round(self.selector_offsets[0] + i * self.cad_gate_width, 1) for i in range(self.mmu_unit.num_gates)]
            else:
                extrapolate = False
            self.var_manager.set(VARS_MMU_SELECTOR_OFFSETS, self.selector_offsets, write=True, namespace=self.mmu_unit.name)

            if extrapolate:
                self.mmu.log_always("All selector offsets have been extrapolated and saved:\n%s" % self.selector_offsets)
            else:
                self.mmu.log_always("Selector offset (%.1fmm) for gate %d has been saved" % (traveled, gate))
                if gate == 0:
                    self.mmu.log_always("Run MMU_CALIBRATE_SELECTOR again with GATE=%d to extrapolate all gate positions. Use SINGLE=1 to force calibration of only one gate" % (self.mmu_unit.num_gates - 1))
        return True

    def _home_selector(self):
        self.mmu.unselect_gate()
        self.mmu.movequeues_wait()
        try:
            if self.has_endstop:
                homing_state = MmuUnit.MmuHoming(self.printer, self.mmu_toolhead)
                homing_state.set_axes([0])
                self.mmu_toolhead.get_kinematics().home(homing_state)
            else:
                self._home_hard_endstop()
            self.is_homed = True
        except Exception as e: # Homing failed
            logging.error(traceback.format_exc())
            raise MmuError("Homing selector failed because of blockage or malfunction. Klipper reports: %s" % str(e))

    def _home_hard_endstop(self):
        self.mmu.log_always("Forcing selector homing to hard endstop. Excuse the noise!\n(Configure stallguard endstop on selector stepper to avoid)")
        self.set_position(self._get_max_selector_movement()) # Worst case position to allow full movement
        self.move("Forceably homing to hard endstop", new_pos=0, speed=self.selector_homing_speed)
        self.set_position(0) # Reset pos

    def _position(self, target):
        self.move("Positioning selector", target)

    def move(self, trace_str, new_pos, speed=None, accel=None, wait=False):
        return self._trace_selector_move(trace_str, new_pos, speed=speed, accel=accel, wait=wait)

    # Internal raw wrapper around all selector moves except rail homing
    # Returns position after move, if homed (homing moves)
    def _trace_selector_move(self, trace_str, new_pos, speed=None, accel=None, wait=False):
        if trace_str:
            self.mmu.log_trace(trace_str)

        self.mmu_toolhead.quiesce()

        # Set appropriate speeds and accel if not supplied
        speed = speed or self.selector_move_speed
        accel = accel or self.mmu_toolhead.get_selector_limits()[1]

        pos = self.mmu_toolhead.get_position()
        with self.mmu.wrap_accel(accel):
            pos[0] = new_pos
            self.mmu_toolhead.move(pos, speed)
        if self.mmu.log_enabled(self.mmu.LOG_STEPPER):
            self.mmu.log_stepper("SELECTOR MOVE: position=%.1f, speed=%.1f, accel=%.1f" % (new_pos, speed, accel))
        if wait:
            self.mmu.movequeues_wait(toolhead=False, mmu_toolhead=True)
        return pos[0]

    def set_position(self, position):
        pos = self.mmu_toolhead.get_position()
        pos[0] = position
        self.mmu_toolhead.set_position(pos, homing_axes=(0,))
        self.enable_motors()
        self.is_homed = True
        return position

    def measure_to_home(self):
        self.mmu.movequeues_wait()
        init_mcu_pos = self.selector_stepper.get_mcu_position()
        homed = False
        try:
            homing_state = MmuUnit.MmuHoming(self.printer, self.mmu_toolhead)
            homing_state.set_axes([0])
            self.mmu_toolhead.get_kinematics().home(homing_state)
            homed = True
        except Exception:
            pass # Home not found
        mcu_position = self.selector_stepper.get_mcu_position()
        traveled = abs(mcu_position - init_mcu_pos) * self.selector_stepper.get_step_dist()
        return traveled, homed



################################################################################
# Servo Selector
# Implements Servo based Selector for type-A MMU's like PicoMMU. Filament is
# always gripped when gate selected but a release position is assumed between
# each gate position (or specified release position, often 0 degrees)
#
# 'filament_always_gripped' alters operation:
#   0 (default) - Lazy gate selection, occurs when asked to grip filament
#   1           - Gripped immediately on selection and will not release
#
# Implements commands:
#   MMU_CALIBRATE_SELECTOR
#   MMU_SOAKTEST_SELECTOR
#   MMU_GRIP    - realign with selected gate
#   MMU_RELEASE - move between gates to release filament
################################################################################

class ServoSelector(PhysicalSelector):

    def __init__(self, config, mmu_unit, params):
        super().__init__(config, mmu_unit, params)
        self.is_homed = True

        self.servo_state = FILAMENT_UNKNOWN_STATE
        self.servo_bypass_angle = -1

        # Get hardware
        self.servo = self.mmu_unit.selector_servo
        if not self.servo:
            raise self.config.error("Selector servo not found")

        # Process config
        self.servo_duration = config.getfloat('servo_duration', 0.5, minval=0.1)
        self.servo_dwell = config.getfloat('servo_dwell', 0.6, minval=0.1)
        self.servo_always_active = config.getint('servo_always_active', 0, minval=0, maxval=1)
        self.servo_min_angle = config.getfloat('servo_min_angle', 0, above=0)                    # Not exposed
        self.servo_max_angle = config.getfloat('servo_max_angle', self.servo.max_angle, above=0) # Not exposed
        self.servo_angle = self.servo_min_angle + (self.servo_max_angle - self.servo_min_angle) / 2
        self.servo_release_angle = config.getfloat('servo_release_angle', -1, minval=-1, maxval=self.servo_max_angle)
        self.servo_bypass_angle = config.getfloat('servo_bypass_angle', -1, minval=-1, maxval=self.servo_max_angle)
        self.servo_gate_angles = list(config.getintlist('servo_gate_angles', []))

        # Register GCODE commands specific to this module
        self.register_mux_command('MMU_CALIBRATE_SELECTOR', self.cmd_MMU_CALIBRATE_SELECTOR, desc=self.cmd_MMU_CALIBRATE_SELECTOR_help)
        self.register_mux_command('MMU_GRIP', self.cmd_MMU_GRIP, desc=self.cmd_MMU_GRIP_help)
        self.register_mux_command('MMU_RELEASE', self.cmd_MMU_RELEASE, desc=self.cmd_MMU_RELEASE_help)

    # Selector "Interface" methods ---------------------------------------------

    def reinit(self):
        self.servo_state = FILAMENT_UNKNOWN_STATE

    def handle_connect(self):
        super().handle_connect()

        self.var_manager.upgrade(VARS_MMU_SELECTOR_ANGLES, self.mmu_unit.name) # v3 upgrade
        self.var_manager.upgrade(VARS_MMU_SELECTOR_BYPASS_ANGLE, self.mmu_unit.name) # v3 upgrade

        # Load and merge calibrated selector angles (calibration set with MMU_CALIBRATE_SELECTOR) ------------
        self.servo_gate_angles = self._ensure_list_size(self.servo_gate_angles, self.mmu_unit.num_gates)

        cal_servo_gate_angles = self.var_manager.get(VARS_MMU_SELECTOR_ANGLES, [], namespace=self.mmu_unit.name)
        if cal_servo_gate_angles:
            self.mmu.log_debug("Loaded saved selector angles: %s" % cal_servo_gate_angles)
        else:
            self.mmu.log_always("Warning: Selector angles not found in mmu_vars.cfg. Using configured defaults")

        # Merge calibrated angles with conf angles
        for gate, angle in enumerate(zip(self.servo_gate_angles, cal_servo_gate_angles)):
            if angle[1] >= 0:
                self.servo_gate_angles[gate] = angle[1]

        if not any(x == -1 for x in self.servo_gate_angles):
            self.calibrator.mark_calibrated(self.calibrator.CALIBRATED_SELECTOR)

        servo_bypass_angle = self.var_manager.get(VARS_MMU_SELECTOR_BYPASS_ANGLE, -1, namespace=self.mmu_unit.name)
        if servo_bypass_angle >= 0:
            self.servo_bypass_angle = servo_bypass_angle
            self.mmu.log_debug("Loaded saved bypass angle: %s" % self.servo_bypass_angle)

    def _ensure_list_size(self, lst, size, default_value=-1):
        lst = lst[:size]
        lst.extend([default_value] * (size - len(lst)))
        return lst

    # Actual gate selection (servo movement) can be delayed until the filament_drive/release instruction
    # to prevent unecessary flutter. Conrolled by `filament_always_gripped` setting
    def select_gate(self, gate):
        if gate != self.mmu.gate_selected:
            with self.mmu.wrap_action(ACTION_SELECTING):
                if self.mmu_unit.filament_always_gripped:
                    self._grip(self.local_gate(gate))

    def restore_gate(self, gate):
        if gate == TOOL_GATE_BYPASS:
            self.servo_state = FILAMENT_RELEASE_STATE
            self.mmu.log_trace("Setting servo to bypass angle: %.1f" % self.servo_bypass_angle)
            self._set_servo_angle(self.servo_bypass_angle)
        else:
            if self.mmu_unit.filament_always_gripped:
                self._grip(self.local_gate(gate))
            else:
                # Defer movement until filament_drive/release/hold call
                self.servo_state = FILAMENT_UNKNOWN_STATE

    def filament_drive(self):
        self._grip(self.local_gate(self.mmu.gate_selected))

    def filament_release(self, measure=False):
        if not self.mmu_unit.filament_always_gripped:
            self._grip(self.local_gate(self.mmu.gate_selected), release=True)
        return 0. # Fake encoder movement

    # Common logic for servo manipulation
    def _grip(self, gate, release=False):
        if gate == TOOL_GATE_BYPASS:
            self.mmu.log_trace("Setting servo to bypass angle: %.1f" % self.servo_bypass_angle)
            self._set_servo_angle(self.servo_bypass_angle)
            self.servo_state = FILAMENT_UNKNOWN_STATE
        elif gate >= 0:
            if release:
                release_angle = self._get_closest_released_angle()
                self.mmu.log_trace("Setting servo to filament released position at angle: %.1f" % release_angle)
                self._set_servo_angle(release_angle)
                self.servo_state = FILAMENT_RELEASE_STATE
            else:
                angle = self.servo_gate_angles[self.local_gate(gate)]
                self.mmu.log_trace("Setting servo to filament grip position at angle: %.1f" % angle)
                self._set_servo_angle(angle)
                self.servo_state = FILAMENT_DRIVE_STATE
        else:
            self.servo_state = FILAMENT_UNKNOWN_STATE

    def get_filament_grip_state(self):
        return self.servo_state

    def buzz_motor(self, motor):
        if motor == "selector":
            prev_servo_angle = self.servo_angle
            low = max(min(self.servo_gate_angles), self.servo_min_angle)
            high = min(max(self.servo_gate_angles), self.servo_max_angle)
            mid = (low + high) / 2
            move = (high - low) / 4
            self._set_servo_angle(angle=mid)
            self._set_servo_angle(angle=mid - move)
            self._set_servo_angle(angle=mid + move)
            self._set_servo_angle(angle=prev_servo_angle)
        else:
            return False
        return True

    def has_bypass(self):
        return self.mmu_unit.has_bypass and self.servo_bypass_angle >= 0

    def get_status(self, eventtime):
        status = super().get_status(eventtime)
        status.update({
            'grip': "Gripped" if self.servo_state == FILAMENT_DRIVE_STATE else "Released",
        })
        return status

    def get_mmu_status_config(self):
        msg = super().get_mmu_status_config()
        msg += ". Servo in %s position" % ("GRIP" if self.servo_state == FILAMENT_DRIVE_STATE else \
                "RELEASE" if self.servo_state == FILAMENT_RELEASE_STATE else "unknown")
        return msg

    def get_uncalibrated_gates(self, check_gates):
        return [lgate + self.mmu_unit.first_gate for lgate, value in enumerate(self.servo_gate_angles) if value == -1 and lgate + self.mmu_unit.first_gate in check_gates]

    # Internal Implementation --------------------------------------------------

    cmd_MMU_GRIP_help = "Grip filament in current gate"
    def cmd_MMU_GRIP(self, gcmd):
        if self.mmu.gate_selected >= 0:
            self.filament_drive()

    cmd_MMU_RELEASE_help = "Ungrip filament in current gate"
    def cmd_MMU_RELEASE(self, gcmd):
        if self.mmu.gate_selected >= 0:
            if not self.mmu_unit.filament_always_gripped:
                self.filament_release()
            else:
                self.mmu.log_error("Selector configured to not allow filament release")

    cmd_MMU_CALIBRATE_SELECTOR_help = "Calibration of the selector servo angle for specifed gate(s)"
    cmd_MMU_CALIBRATE_SELECTOR_param_help = (
        "MMU_CALIBRATE_SELECTOR: %s\n" % cmd_MMU_CALIBRATE_SELECTOR_help
        + "UNIT    = #(int)\n"
        + "GATE    = #(int) Optional, default all gates on unit\n"
        + "SHOW    = [0,1]\n"
        + "ANGLE   = #(int)\n"
        + "SAVE    = [0|1]\n"
        + "SINGLE  = [0|1]\n"
        + "SPACING = #.#(float)\n"
        + "BYPASS  = [0|1]\n"
    )
    def cmd_MMU_CALIBRATE_SELECTOR(self, gcmd):
        self.mmu.log_to_file(gcmd.get_commandline())
        if self.mmu.check_if_disabled(): return

        usage = "\nUsage: MMU_CALIBRATE_SELECTOR [GATE=x] [BYPASS=0|1] [SPACING=x] [ANGLE=x] [SAVE=0|1] [SINGLE=0|1] [SHOW=0|1]"
        show = gcmd.get_int('SHOW', 0, minval=0, maxval=1)
        angle = gcmd.get_int('ANGLE', None)
        save = gcmd.get_int('SAVE', 1, minval=0, maxval=1)
        single = gcmd.get_int('SINGLE', 0, minval=0, maxval=1)
        spacing = gcmd.get_float('SPACING', 25., above=0, below=180) # TiPicoMMU is 25 degrees between gates
        gate = gcmd.get_int('GATE', -1, minval=0, maxval=self.mmu_unit.num_gates - 1)
        if gate == -1 and gcmd.get_int('BYPASS', -1, minval=0, maxval=1) == 1:
            gate = TOOL_GATE_BYPASS

        if help:
            self.mmu.log_always(self.mmu.format_help(self.cmd_MMU_CALIBRATE_SELECTOR_param_help), color=True)
            return

        if show:
            msg = ""
            if not self.calibrator.check_calibrated(self.calibrator.CALIBRATED_SELECTOR):
                msg += "Calibration not complete\n"
            msg += "Current selector gate angle positions are: %s degrees" % self.servo_gate_angles
            if self.servo_release_angle >= 0:
                msg += "\nRelease angle is fixed at: %s degrees" % self.servo_release_angle
            else:
                msg += "\nRelease angles configured to be between each gate angle"
            if self.has_bypass():
                msg += "\nBypass angle: %s" % self.servo_bypass_angle
            else:
                msg += "\nBypass angle not configured"
            self.mmu.log_info(msg)

        elif angle is not None:
            self.mmu.log_debug("Setting selector servo to angle: %d" % angle)
            self._set_servo_angle(angle)
            self.servo_state = FILAMENT_UNKNOWN_STATE

        elif save:
            if gate == TOOL_GATE_BYPASS:
                self.servo_bypass_angle = self.servo_angle
                self.var_manager.set(VARS_MMU_SELECTOR_BYPASS_ANGLE, self.servo_bypass_angle, write=True, namespace=self.mmu_unit.name)
                self.mmu.log_info("Servo angle '%d' for bypass position has been saved" % self.servo_angle)
            elif gate >= 0:
                if single:
                    self.servo_gate_angles[gate] = self.servo_angle
                    self.var_manager.set(VARS_MMU_SELECTOR_ANGLES, self.servo_gate_angles, write=True, namespace=self.mmu_unit.name)
                    self.mmu.log_info("Servo angle '%d' for gate %d has been saved" % (self.servo_angle, gate))
                else:
                    # If possible evenly distribute based on spacing
                    angles = self._generate_gate_angles(self.servo_angle, gate, spacing)
                    if angles:
                        self.servo_gate_angles = angles
                        self.var_manager.set(VARS_MMU_SELECTOR_ANGLES, self.servo_gate_angles, write=True, namespace=self.mmu_unit.name)
                        self.mmu.log_info("Selector gate angle positions %s has been saved" % self.servo_gate_angles)
                    else:
                        self.mmu.log_error("Not possible to distribute angles with separation of %.1f degrees with gate %d at %.1f%s" % (spacing, gate, self.servo_angle, usage))
            else:
                self.mmu.log_error("No gate specified%s" % usage)
        else:
            self.mmu.log_always("Current selector servo angle: %d, Selector gate angle positions: %s" % (self.servo_angle, self.servo_gate_angles))

        if not any(x == -1 for x in self.servo_gate_angles):
            self.calibrator.mark_calibrated(self.calibrator.CALIBRATED_SELECTOR)

    def _set_servo_angle(self, angle):
        if angle >= 0 and angle != self.servo_angle:
            self.mmu.movequeues_wait()
            self.servo.set_position(angle=angle, duration=None if self.servo_always_active else self.servo_duration)
            self.servo_angle = angle
            self.mmu.movequeues_dwell(max(self.servo_dwell, self.servo_duration, 0))

    def _get_closest_released_angle(self):
        if self.servo_release_angle >= 0:
            return self.servo_release_angle
        neutral_angles = [(self.servo_gate_angles[i] + self.servo_gate_angles[i + 1]) / 2 for i in range(len(self.servo_gate_angles) - 1)]
        closest_angle = 0
        min_difference = float('inf')
        for angle in neutral_angles:
            difference = abs(angle - self.servo_angle)
            if difference < min_difference:
                min_difference = difference
                closest_angle = max(0, angle)
        return closest_angle

    def _generate_gate_angles(self, known_angle, known_gate, spacing):
        angles = []
        start_angle = known_angle - known_gate * spacing
        for i in range(self.mmu_unit.num_gates):
            a = start_angle + i * spacing
            if not (self.servo_min_angle <= a <= self.servo_max_angle):
                return None # Not possible
            angles.append(round(a))
        return angles



################################################################################
# Indexed Selector
# Implements simple Indexed Selector for type-A MMU's that uses a stepper for
# gate selection but has an indexing sensor for each gate.
# E.g. As fitted to BTT ViViD
#
# Implements commands:
#   MMU_SOAKTEST_SELECTOR
################################################################################

class IndexedSelector(PhysicalSelector):

    def __init__(self, config, mmu_unit, params):
        super().__init__(config, mmu_unit, params)
        self.is_homed = True

        # Process config
        self.selector_move_speed = config.getfloat('selector_move_speed', 100, minval=1.)
        self.selector_homing_speed = config.getfloat('selector_homing_speed', self.selector_move_speed, minval=1.)
        self.selector_index_distance = config.getfloat('selector_index_distance', 5, minval=0.)

        # To simplfy config CAD related parameters are set based on vendor and version setting
        self.cad_gate_width = 90. # Rotation distance set to make this equivalent to degrees
        self.cad_max_rotations = 2

        # But still allow all CAD parameters to be customized
        self.cad_gate_width = config.getfloat('cad_gate_width', self.cad_gate_width, above=0.)
        self.cad_max_rotations = config.getfloat('cad_max_rotations', self.cad_max_rotations, above=0.)

        self.unit_gate_selected = 0 # TODO could be set as part of startup homing..

        # Selector stepper setup before MMU toolhead is instantiated
        section = mmu_machine.SELECTOR_STEPPER_CONFIG
        if config.has_section(section):
            # Inject options into selector stepper config regardless or what user sets
            config.fileconfig.set(section, 'homing_speed', self.selector_homing_speed)

    # Selector "Interface" methods ---------------------------------------------

    def handle_connect(self):
        super().handle_connect()

        self.mmu_toolhead = self.mmu.mmu_toolhead
        self.selector_rail = self.mmu_toolhead.get_kinematics().rails[0]
        self.selector_stepper = self.selector_rail.steppers[0]
        self._set_position(0) # Reset pos

# PAUL        # Adjust selector rail limits now we know the config
# PAUL        self.selector_rail.homing_speed = self.selector_homing_speed
# PAUL        self.selector_rail.second_homing_speed = self.selector_homing_speed / 2.
# PAUL        self.selector_rail.homing_retract_speed = self.selector_homing_speed
# PAUL        self._set_position(0) # Reset pos

    def bootup(self):
        self.select_gate(self.mmu.gate_selected)

    def home(self, force_unload = None):
        if self.mmu.check_if_bypass(): return
        with self.mmu.wrap_action(ACTION_HOMING):
            self.mmu.log_info("Homing MMU...")
            if force_unload is not None:
                self.mmu.log_debug("(asked to %s)" % ("force unload" if force_unload else "not unload"))
            if force_unload is True:
                # Forced unload case for recovery
                self.mmu.unload_sequence(check_state=True)
            elif force_unload is None and self.mmu.filament_pos != FILAMENT_POS_UNLOADED:
                # Automatic unload case
                self.mmu.unload_sequence()
            self._home_selector()

    def select_gate(self, gate):
        if gate >= 0:
            endstop = self.selector_rail.get_extra_endstop(self._get_gate_endstop(gate))
            if not endstop:
                raise MmuError("Extra endstop %s not defined on the selector stepper" % self._get_gate_endstop(gate))
            mcu_endstop = endstop[0][0]
            if not mcu_endstop.query_endstop(self.mmu_toolhead.get_last_move_time()):
                with self.mmu.wrap_action(ACTION_SELECTING):
                    self._find_gate(gate)

    def disable_motors(self):
        stepper_enable = self.printer.lookup_object('stepper_enable')
        se = stepper_enable.lookup_enable(self.selector_stepper.get_name())
        se.motor_disable(self.mmu_toolhead.get_last_move_time())
        self.is_homed = False

    def enable_motors(self):
        stepper_enable = self.printer.lookup_object('stepper_enable')
        se = stepper_enable.lookup_enable(self.selector_stepper.get_name())
        se.motor_enable(self.mmu_toolhead.get_last_move_time())

    def buzz_motor(self, motor):
        if motor == "selector":
            pos = self.mmu_toolhead.get_position()[0]
            self.move(None, pos + 5, wait=False)
            self.move(None, pos - 5, wait=False)
            self.move(None, pos, wait=False)
        else:
            return False
        return True

    def get_mmu_status_config(self):
        msg = "\nSelector is NOT HOMED" if not self.is_homed else ""
        return msg

    def set_test_config(self, gcmd):
        self.selector_move_speed = gcmd.get_float('SELECTOR_MOVE_SPEED', self.selector_move_speed, minval=1.)
        self.selector_homing_speed = gcmd.get_float('SELECTOR_HOMING_SPEED', self.selector_homing_speed, minval=1.)

    def get_test_config(self):
        msg = "\n\nSELECTOR:"
        msg += "\nselector_move_speed = %.1f" % self.selector_move_speed
        msg += "\nselector_homing_speed = %.1f" % self.selector_homing_speed
        return msg

    # Internal Implementation --------------------------------------------------

    def _get_max_selector_movement(self):
        max_movement = self.mmu_unit.num_gates * self.cad_gate_width * self.cad_max_rotations
        return max_movement

    def _home_selector(self):
        self.mmu.unselect_gate()
        self.mmu.movequeues_wait()
        try:
            self._find_gate(0)
            self.is_homed = True
        except Exception as e: # Homing failed
            logging.error(traceback.format_exc())
            raise MmuError("Homing selector failed because of blockage or malfunction. Klipper reports: %s" % str(e))

    def _get_gate_endstop(self, gate):
        return "unit0_gate%d" % gate

    def _find_gate(self, gate):
        rotation_dir = self._best_rotation_direction(self.mmu.gate_selected, gate)
        max_move = self._get_max_selector_movement() * rotation_dir
        self.mmu.movequeues_wait()
        actual,homed = self._trace_selector_move("Indexing selector", max_move, speed=self.selector_move_speed, homing_move=1, endstop_name=self._get_gate_endstop(gate))
        if abs(actual) > 0 and homed:
            # If we actually moved to home make sure we are centered on index endstop
            center_move = (self.selector_index_distance / 2) * rotation_dir
            self._trace_selector_move("Centering selector", center_move, speed=self.selector_move_speed)

    # TODO automate the setup of the sequence through homing move on startup
    def _best_rotation_direction(self, start_gate, end_gate):
        if start_gate < 0:
            return 1 # Forward direction

        sequence = [0, 2, 1, 3] # Forward order of gates
        n = len(sequence)
        forward_distance = reverse_distance = 0

        # Find distance in forward direction
        start_idx = sequence.index(start_gate)
        for i in range(1, n):
            if sequence[(start_idx + i) % n] == end_gate:
                forward_distance = i
                break

        # Find distance in reverse direction
        rev_seq = sequence[::-1]
        start_idx = rev_seq.index(start_gate)
        for i in range(1, n):
            if rev_seq[(start_idx + i) % n] == end_gate:
                reverse_distance = i
                break

        return 1 if forward_distance <= reverse_distance else -1

    # Internal raw wrapper around all selector moves
    # Returns position after move, and if homed (homing moves)
    def _trace_selector_move(self, trace_str, dist, speed=None, accel=None, homing_move=0, endstop_name="default", wait=False):
        null_rtn = (0., False)
        homed = False
        actual = dist

        self.mmu_unit.mmu_toolhead.quiesce()

        if homing_move != 0:
            # Check for valid endstop
            endstops = self.selector_rail.get_endstops() if endstop_name is None else self.selector_rail.get_extra_endstop(endstop_name)
            if endstops is None:
                self.mmu.log_error("Endstop '%s' not found" % endstop_name)
                return null_rtn

        # Set appropriate speeds and accel if not supplied
        speed = speed or self.selector_homing_speed if homing_move != 0 else self.selector_move_speed
        accel = accel or self.mmu_toolhead.get_selector_limits()[1]

        pos = self.mmu_toolhead.get_position()
        if homing_move != 0:
            try:
                with self.mmu.wrap_accel(accel):
                    init_pos = pos[0]
                    pos[0] += dist
                    trig_pos = [0., 0., 0., 0.]
                    hmove = HomingMove(self.printer, endstops, self.mmu_toolhead)
                    trig_pos = hmove.homing_move(pos, speed, probe_pos=True, triggered=homing_move > 0, check_triggered=True)
                    homed = True
            except self.printer.command_error as e:
                homed = False

            halt_pos = self.mmu_toolhead.get_position()
            actual = halt_pos[0] - init_pos
            if self.mmu.log_enabled(self.mmu.LOG_STEPPER):
                self.mmu.log_stepper("SELECTOR HOMING MOVE: max dist=%.1f, speed=%.1f, accel=%.1f, endstop_name=%s, wait=%s >> %s" % (dist, speed, accel, endstop_name, wait, "%s halt_pos=%.1f (rail moved=%.1f), trig_pos=%.1f" % ("HOMED" if homed else "DID NOT HOMED",  halt_pos[0], actual, trig_pos[0])))

        else:
            with self.mmu.wrap_accel(accel):
                pos[0] += dist
                self.mmu_toolhead.move(pos, speed)
            if self.mmu.log_enabled(self.mmu.LOG_STEPPER):
                self.mmu.log_stepper("SELECTOR MOVE: position=%.1f, speed=%.1f, accel=%.1f" % (dist, speed, accel))

        self.mmu_toolhead.flush_step_generation() # TTC mitigation (TODO: still required?)
        self.mmu.toolhead.flush_step_generation() # TTC mitigation (TODO: still required?)
        if wait:
            self.mmu.movequeues_wait(toolhead=False, mmu_toolhead=True)

        if trace_str:
            if homing_move != 0:
                trace_str += ". Stepper: selector %s after moving %.1fmm (of max %.1fmm)"
                trace_str = trace_str % (("homed" if homed else "did not home"), actual, dist)
                trace_str += ". Pos: @%.1f" % self.mmu_toolhead.get_position()[0]
            else:
                trace_str += ". Stepper: selector moved %.1fmm" % dist
            trace_str += ". Pos: @%.1f" % self.mmu_toolhead.get_position()[0]
            self.mmu.log_trace(trace_str)

        return actual, homed

    def _set_position(self, position):
        pos = self.mmu_toolhead.get_position()
        pos[0] = position
        self.mmu_toolhead.set_position(pos)
        self.enable_motors()
        self.is_homed = True
        return position
